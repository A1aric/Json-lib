<?xml version="1.0" encoding="UTF-8"?>
<document>

   <properties>
      <title>Json-lib::Advanced Features</title>
   </properties>

   <body>
      <section name="Advanced Features">
         <subsection name="Transforming key names">
            The
            <a href="http://json.org">JSON spec</a>
            states that an object key is a String and
            <blockquote>
               A string is a collection of zero or more Unicode
               characters, wrapped in double quotes, using backslash
               escapes. A character is represented as a single character
               string. A string is very much like a C or Java string.
            </blockquote>
            This means that you may have a valid JSON key but and invalid Java identifier
            when transforming form JSON to Java. In order to avoid this problem, Json-lib
            defines a set of helpers of type JavaIdentifierTransformer that will handle
            the following cases:<ul>
            <li>JavaIdentifierTransformer.NOOP - will perform no transformation.</li>
            <li>JavaIdentifierTransformer.STRICT - will throw JSONException if a non JavaIdentifier character is found.</li>
            <li>JavaIdentifierTransformer.CAMEL_CASE - will use non JavaIdentifier and whitespace characters as word boundaries, 
            capitalizing the first char of a new word.</li>
            <li>JavaIdentifierTransformer.WHITESPACE - will trim all whitespace and non JavaIdentifier characters from the input string.</li>
            <li>JavaIdentifierTransformer.UNDERSCORE - will transform all whitespace and non JavaIdentifier characters to '_'.</li>
            </ul>You may also create and register your own JavaIdentifierTransformers using <tt>JsonConfig.setJavaIdentifierTransformer()</tt>
         </subsection>
         
         <subsection name="Build events">
         You may recieve events while building an object with the JSONSerializer or the static builder <tt>fromObject</tt> of 
         JSONObject&amp;JSONArray, all you have to do is enabled event triggering on JsonConfig. The following is a list of events
         generated by the build process: start/end (object), start/end (array), propertySet( object), elementAdd (array), warning, error.
         </subsection>
         
         <subsection name="Skipping transient fields">
         When building a JSONObject with <tt>fromObject</tt> or with the JSONSerializer you may skip all transient fields of the source
         bean, provided that the name of the property returned from the PropertyDescriptor matches the name of the field, meaning that
         this option will not work if you have a BeanInfo that changes the name of a read method or provides a synthetic property.
         </subsection>

	 <subsection name="Filtering properties">
	 <p>
	 When serializing to JSON there may be some times where you would like to exclude some properties from being processed, the current exclusion mechanism matches the property name to a list of Strings, but what if you would like to filter out all properties that match a regex or extend a particular class? PropertyFilter will help you attain that goal with ease, and what's more, it will also work when converting back to Java. Here is an example filter that will exclude all properties that are a Number when serializing to JSON:
 </p><textarea cols="70" rows="11" class="java:nocontrols:nogutter" name="srccode">
   PrimitiveBean bean = new PrimitiveBean();
   JsonConfig jsonConfig = new JsonConfig();
   jsonConfig.setJsonPropertyFilter( new PropertyFilter(){
      public boolean apply( Object source, String name, Object value ) {
         if( value != null &amp;&amp; Number.class.isAssignableFrom( value.getClass() ) ){
            return true;
         }
         return false;
      }
   });
   JSONObject json = JSONObject.fromObject( bean, jsonConfig );</textarea><p>
   This is another filter example, this time converting back to Java, it will filter out any property named 'bool' or 'integer':
 </p><textarea cols="70" rows="13" class="java:nocontrols:nogutter" name="srccode">
   BeanA bean = new BeanA();
   JSONObject json = JSONObject.fromObject( bean );
   JsonConfig jsonConfig = new JsonConfig();
   jsonConfig.setRootClass( BeanA.class );
   jsonConfig.setJavaPropertyFilter( new PropertyFilter(){
      public boolean apply( Object source, String name, Object value ) {
         if( "bool".equals( name ) || "integer".equals( name ) ){
            return true;
         }
         return false;
      }
   });
   BeanA actual = (BeanA) JSONObject.toBean( json, jsonConfig );</textarea><p>Please review the <code>net.sf.json.filters</code> package to find out more about default filters and composite filters.</p>
         </subsection>

         <subsection name="Selecting the proper JsonBeanProcessor">
	 <code>JsonBeanProcessor</code>s are maped to classes but sometimes you'll like that some subclasses may be mapped to the same
	 processor or perhaps you are serializing a recently hydrated instance coming from a database with Hibernate, because the instance's
	 class is not exactly the one you expect (it actually is a cglib proxy class) the default class matching mechanism will not work.
	 In order to solve these problems you may register a <code>JsonBeanProcessorMatcher</code> that will take care of the job of selecting
	 the proper <code>JsonBeanProcessor</code>, just as you need it.
         </subsection>

	 <subsection name="Instantiating non JavaBeans">
	 When serializing from JSON to Java you have to keep one rule in mind, the target class must follow the JavaBeans convention of a
	 no-args constructor but sometimes it won't be possible, as it is the case of <code>java.sql.Timestamp</code>. Json-lib has an option
	 to overcome this "restriction", just register a <code>NewBeanInstanceStrategy</code> into JsonConfig and you are in business.
         </subsection>

      </section>
   </body>
</document>
